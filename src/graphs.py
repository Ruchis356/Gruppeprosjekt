import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import matplotlib.dates as mdates
import logging # The use of logging was suggested by AI (DeepSeek)
logging.basicConfig(
    format='%(asctime)s - %(levelname)s - %(message)s',
    level=logging.INFO
)


class Graphs:
    """A class for creating visual representation of data in the form of graphs based on dataframes"""

    def __init__(self):
        """Initialize graph styles and settings."""

        # The following block of code was generated by AI
            # Purpose: AI suggested setting a general theme for the class and generated the relevant code
            # AI Tool: DeepSeek
        sns.set_theme(
            style="whitegrid", 
            palette="colorblind",  
            font_scale=1.1 
        )
        
        plt.rcParams['figure.facecolor'] = 'white'
        self.logger = logging.getLogger(__name__)
        self.df = None

    # ---------------------------------------------------
    # CREATE DOT GRAPHIC VISUALISATION OF DATA
    # ---------------------------------------------------

    def dot_graph(self, df, columns, title, x_axis, y_axis, color=None):

        """
        Plots a scattergraph with multiple variables.
        
        Args:
            df (pd.DataFrame): DataFrame containing time-series data to plot.
            columns (list): List of column names in 'df' to plot.
            title (str): Title of the plot.
            x_axis (str): Label for the x-axis.
            y_axis (str): Label for the y-axis.
            color (str): Specify color for single variable plots.

        """
        self.logger.debug(f"Plotting {len(columns)} variables")

        # Input validation
        if df.empty:
            raise ValueError("Input DataFrame cannot be empty.")
        if not columns:
            raise ValueError("Columns list cannot be empty.")

        # Converting Date column to datetime if they aren't already
        df['Date'] = pd.to_datetime(df['Date'])

        # Create figure
        plt.figure(figsize=(12, 6))
        colors = plt.rcParams['axes.prop_cycle'].by_key()['color']

        # Create scattergraph based on the given columns in the given dataframe
        for i, column in enumerate(columns):

            if color is not None and len(columns) == 1:
                plot_color = color
            else:
                plot_color = colors[i % len(colors)]

            sns.scatterplot(data=df, x='Date', y=column, 
                            label=column, 
                            color=plot_color,
                            alpha=0.5) # This line was generated by AI (DeepSeek)

        # Formatting
        plt.title(title)
        plt.xlabel(x_axis)
        plt.ylabel(y_axis)
        plt.grid(True, alpha=0.3)
        plt.legend()
        plt.xticks(rotation=45)
        plt.gca().xaxis.set_major_locator(mdates.AutoDateLocator(minticks=8, maxticks=12)) 
        plt.tight_layout()

        plt.show(block=False)  
        plt.close()       

    # ---------------------------------------------------
    # CREATE COMPARATIVE GRAPH OF DATA AND PREDICTOR
    # ---------------------------------------------------

    # This function was refined with the assitance of AI
        # Purpose: AI helped find better solutions for aligning the origins of both y-axis
        # AI Tool: DeepSeek

    def comparative_graph(self, df, columns, df_predictor, predictor, title, x_axis, y_axis, y_lims=None, zero_align=False):

        """
        Plots time-series data (primary y-axis) against a predictor variable (secondary y-axis) on twin axes.
        Handles mismatched dates and ensures visual distinction between variables.

        Args:
            df (pd.DataFrame): DataFrame containing time-series data to plot (primary axis).
            columns (list): List of column names in `df` to plot.
            df_predictor (pd.DataFrame): DataFrame containing the predictor variable (secondary axis).
            predictor (str): Column name in `df_predictor` to plot.
            title (str): Title of the plot.
            x_axis (str): Label for the x-axis.
            y_axis (str): Label for the primary y-axis.
            y_lims (tuple, optional): (min, max) limits for the secondary y-axis. If None, auto-scales. Defaults to None.
            zero_align (bool, optional): If True, aligns 0 on both y-axis. Defaults to False.
        """
        
        self.logger.debug(f"Plotting {len(columns)} variables vs {predictor}")

        #Input validation
        if df.empty or df_predictor.empty:
            raise ValueError("Input DataFrames cannot be empty.")
        if predictor not in df_predictor.columns:
            raise ValueError(f"Predictor column '{predictor}' not found.")

        # Converting Date column to datetime 
        df['Date'] = pd.to_datetime(df['Date'])
        df_predictor['Date'] = pd.to_datetime(df_predictor['Date'])

        # Find dateranges for overlapping datasets
        primary_non_nan = df[columns].notna().any(axis=1)
        primary_dates = df.loc[primary_non_nan, 'Date']
        predictor_non_nan = df_predictor[predictor].notna()
        predictor_dates = df_predictor.loc[predictor_non_nan, 'Date']

        x_min = max(primary_dates.min(), predictor_dates.min())
        x_max = min(primary_dates.max(), predictor_dates.max())

        # Filter datasets to this range
        df_overlap = df[(df['Date'] >= x_min) & (df['Date'] <= x_max)]
        df_predictor_overlap = df_predictor[(df_predictor['Date'] >= x_min) & (df_predictor['Date'] <= x_max)]
        if df_overlap.empty or df_predictor_overlap.empty:
            raise ValueError("No overlapping data points between datasets")

        # Create figure
        fig, ax1 = plt.subplots(figsize=(12, 6))
        colors = plt.rcParams['axes.prop_cycle'].by_key()['color'] #This line was generate by AI (DeepSeek)

        # The following block of code was generated with the help of AI
            # Purpose: Creating plots with different colours based on the given columns
            # AI Tool: DeepSeek

        # Primary y-axis: Plot all dependent variables
        for i, col in enumerate(columns):
            sns.scatterplot(data=df_overlap, x='Date', y=col, 
                            label=col, 
                            color=colors[i % len(colors)], 
                            alpha=0.5,
                            ax=ax1)
            
        # Calculate primary axis range
        y1_min = min(0, df_overlap[columns].min().min())
        y1_max = df_overlap[columns].max().max()
        y1_padding = (y1_max - y1_min) * 0.05
        ax1.set_ylim(y1_min - y1_padding, y1_max + y1_padding)

        # Secondary y-axis for independent variable
        ax2 = ax1.twinx()
        predictor_color = 'black'
        ax2.plot(df_predictor_overlap['Date'], df_predictor_overlap[predictor], 
                 label=predictor, 
                 color=predictor_color, 
                 lw=1, 
                 alpha=0.5) 

        # Set secondary axis limits
        predictor_data = df_predictor_overlap[predictor]
        predictor_min, predictor_max = predictor_data.min(), predictor_data.max()
        
        if y_lims is not None:
            ax2.set_ylim(y_lims)
        else:
            data_range = predictor_max - predictor_min
            padding = data_range * 0.2 if data_range < 10 else data_range * 0.1
            bottom = max(0, predictor_min - padding)
            top = predictor_max + padding
            ax2.set_ylim(bottom, top)

        # The following block of code was generated by AI
            # Purpose: Solving the problem of aligning the two y-axis
            # AI Tool: DeepSeek

        # Zero alignment
        if zero_align:
            fig.canvas.draw()
            original_bottom, original_top = ax2.get_ylim()
            original_range = original_top - original_bottom
            ax1_zero_disp = ax1.transData.transform((0, 0))[1]
            ax2_zero_disp = ax2.transData.transform((0, 0))[1]
            data_per_pixel = original_range / ax2.bbox.height
            required_shift = (ax1_zero_disp - ax2_zero_disp) * data_per_pixel
            ax2.set_ylim(original_bottom - required_shift, 
                        original_top - required_shift)

        # Graph formatting
        ax1.set_xlabel(x_axis)
        ax1.set_ylabel(y_axis, color='black')
        ax2.set_ylabel(predictor, color=predictor_color)
        ax1.tick_params(axis='y', labelcolor='black')
        ax2.tick_params(axis='y', labelcolor=predictor_color)
        ax1.grid(True, alpha=0.3) 
        ax1.set_xlim(x_min, x_max)
        ax1.xaxis.set_major_locator(mdates.AutoDateLocator())

        ax1.legend(loc='upper left', framealpha=0.9)
        ax2.legend(loc='upper right', framealpha=0.9)

        plt.title(title, pad=20)
        plt.xticks(rotation=45)
        plt.subplots_adjust(top=0.9)
        plt.tight_layout()
        plt.show(block=False)
        plt.close(fig) 