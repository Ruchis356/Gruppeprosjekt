import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import matplotlib.dates as mdates
import numpy as np

class Graphs:

    def __init__(self):
        self.df = None

    # ---------------------------------------------------
    # CREATE DOT GRAPHIC VISUALISATION OF DATA
    # ---------------------------------------------------

    """
    Plots a scattergraph with multiple variables.
    
    Args:
        df (pd.DataFrame): DataFrame containing time-series data to plot.
        columns (list): List of column names in 'df' to plot.
        title (str): Title of the plot.
        x_axis (str): Label for the x-axis.
        y_axis (str): Label for the y-axis.

    """

    def dot_graph(self, df, columns, title, x_axis, y_axis):

        # Create figure
        plt.figure(figsize=(12, 6))
        colors = plt.rcParams['axes.prop_cycle'].by_key()['color']

        # Create scattergraph based on the given columns in the given dataframe
        for i, column in enumerate(columns):
            sns.scatterplot(data=df, x='Date', y=column, 
                            label=column, 
                            color=colors[i % len(colors)],
                            alpha=0.7) # This line was written with assistane from AI (DeepSeek)

        # Formatting
        plt.title(title)
        plt.xlabel(x_axis)
        plt.ylabel(y_axis)
        plt.grid(True, alpha=0.3)
        plt.legend()
        plt.xticks(rotation=45)
        plt.gca().xaxis.set_major_locator(mdates.AutoDateLocator(minticks=8, maxticks=12)) 
        plt.tight_layout()
        plt.show()        

    # ---------------------------------------------------
    # CREATE COMPARATIVE GRAPH OF DATA AND PREDICTOR
    # ---------------------------------------------------

    """
    Plots time-series data (primary y-axis) against a predictor variable (secondary y-axis) on twin axes.
    Handles mismatched dates and ensures visual distinction between variables.

    Args:
        df (pd.DataFrame): DataFrame containing time-series data to plot (primary axis).
        columns (list): List of column names in `df` to plot.
        df_predictor (pd.DataFrame): DataFrame containing the predictor variable (secondary axis).
        predictor (str): Column name in `df_predictor` to plot.
        title (str): Title of the plot.
        x_axis (str): Label for the x-axis.
        y1_axis (str): Label for the primary y-axis.
        y_lims (tuple): Limits for the secondary y-axis.
        zero_align (bool): If True, aligns 0 on both y-axis.

    Notes:
        This function will plot all the dates in both dataframes, regardless of if both dataframes have data on a givn date
    """

    def comparative_graph(self, df, columns, df_predictor, predictor, title, x_axis, y_axis, y_lims, zero_align):
        
        # Converting Date column to datetime if they aren't already
        df['Date'] = pd.to_datetime(df['Date'])
        df_predictor['Date'] = pd.to_datetime(df_predictor['Date'])

        # Getting the full range of dates, min/max of both datasets
        all_dates = pd.concat([df['Date'], df_predictor['Date']]) # This line was generated by AI (DeepSeek)
        x_min, x_max = all_dates.min(), all_dates.max()

        # Create figure
        fig, ax1 = plt.subplots(figsize=(12, 6))
        colors = plt.rcParams['axes.prop_cycle'].by_key()['color'] #This line was generate by AI (DeepSeek)

        # The following block of code was generate with the help of AI
        # Tool: DeepSeek
        # Purpose: Creating plots with different colours based on the given columns

        # Primary y-axis: Plot all dependent variables
        for i, col in enumerate(columns):
            ax1.plot(df['Date'], df[col], 
                label=col, 
                color=colors[i % len(colors)], 
                lw=1,
                alpha=0.7)
            
        # Calculate primary axis range with padding
        y1_min = min(0, df[columns].min().min())
        y1_max = df[columns].max().max()
        y1_padding = (y1_max - y1_min) * 0.05
        ax1.set_ylim(y1_min - y1_padding, y1_max + y1_padding)

        # Secondary y-axis for independent variable
        ax2 = ax1.twinx()
        predictor_color = 'tab:red'
        ax2.plot(df_predictor['Date'], df_predictor[predictor], 
                 label=predictor, 
                 color=predictor_color, 
                 lw=2, 
                 linestyle='--') # linestyle was suggested by AI (DeepSeek)
 
        # Alignment of y-axis' if zero_align=True
        if zero_align:
            # Calculate the required shift to align zeros
            fig.canvas.draw()  # Force layout calculation
            
            # Get data coordinates of zeros
            y1_zero = ax1.transData.transform((0, 0))[1]  # Display y-coord of primary zero
            y2_zero = ax2.transData.transform((0, 0))[1]  # Display y-coord of secondary zero
            
            # Calculate needed adjustment in data units
            y2_data_per_pixel = (y_lims[1] - y_lims[0]) / ax2.bbox.height
            required_shift = (y1_zero - y2_zero) * y2_data_per_pixel
            
            # Apply adjustment
            current_lims = ax2.get_ylim()
            ax2.set_ylim(current_lims[0] - required_shift, 
                        current_lims[1] - required_shift)
        else:
            ax2.set_ylim(y_lims)

        # Graph formatting
        ax1.set_xlabel(x_axis)
        ax1.set_ylabel(y_axis, color='black')
        ax2.set_ylabel(predictor, color=predictor_color)
        ax1.tick_params(axis='y', labelcolor='black')
        ax2.tick_params(axis='y', labelcolor=predictor_color)
        ax1.grid(True, alpha=0.3) 
        ax1.set_xlim(x_min, x_max)
        ax1.xaxis.set_major_locator(mdates.AutoDateLocator())

        '''# Final adjustment for alignment
        if zero_align:
            # Get display coordinates of zeros
            y1_zero_disp = ax1.transData.transform((0, 0))[1]
            y2_zero_disp = ax2.transData.transform((0, 0))[1]
            
            # Calculate and apply needed adjustment
            y2_adjust = (y1_zero_disp - y2_zero_disp) / ax2.transData.transform((0, 1))[1] * (y_lims[1] - y_lims[0])
            current_lims = ax2.get_ylim()
            ax2.set_ylim(current_lims[0] - y2_adjust, current_lims[1] - y2_adjust)
        
        else:
            ax2.set_ylim(y_lims)  '''


        ax1.legend(loc='upper left', framealpha=0.9)
        ax2.legend(loc='upper right', framealpha=0.9)

        plt.title(title, pad=20)
        plt.xticks(rotation=45)
        plt.subplots_adjust(top=0.9)
        plt.tight_layout()
        plt.show()



    



