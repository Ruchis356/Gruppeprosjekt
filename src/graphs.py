import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import matplotlib.dates as mdates
from datetime import datetime, timedelta
import logging # The use of logging was suggested by AI (DeepSeek)
logging.basicConfig(
    format='%(asctime)s - %(levelname)s - %(message)s',
    level=logging.INFO
)


class Graphs:
    """A class for creating visual representation of data in the form of graphs based on dataframes"""

    def __init__(self):
        """Initialize graph styles and settings."""

        # The following block of code was generated by AI
            # Purpose: AI suggested setting a general theme for the class and generated the relevant code
            # AI Tool: DeepSeek
        sns.set_theme(
            style="whitegrid", 
            palette="colorblind",  
            font_scale=1.1 
        )
        
        plt.rcParams['figure.facecolor'] = 'white'
        self.logger = logging.getLogger(__name__)
        self.df = None

    # ---------------------------------------------------
    # CREATE DOT GRAPHIC VISUALISATION OF DATA
    # ---------------------------------------------------

    def dot_graph(self, df, columns, title, x_axis, y_axis, color=None):

        """
        Plots a scattergraph with multiple variables.
        
        Args:
            df (pd.DataFrame): DataFrame containing time-series data to plot.
            columns (list): List of column names in 'df' to plot.
            title (str): Title of the plot.
            x_axis (str): Label for the x-axis.
            y_axis (str): Label for the y-axis.
            color (str): Specify color for single variable plots.

        """
        self.logger.debug(f"Plotting {len(columns)} variables")

        # Input validation
        if df.empty:
            raise ValueError("Input DataFrame cannot be empty.")
        if not columns:
            raise ValueError("Columns list cannot be empty.")

        # Converting Date column to datetime if they aren't already
        df['Date'] = pd.to_datetime(df['Date'])

        # Create figure
        plt.figure(figsize=(12, 6))
        colors = plt.rcParams['axes.prop_cycle'].by_key()['color']

        # Create scattergraph based on the given columns in the given dataframe
        for i, column in enumerate(columns):

            if color is not None and len(columns) == 1:
                plot_color = color
            else:
                plot_color = colors[i % len(colors)]

            sns.scatterplot(data=df, x='Date', y=column, 
                            label=column, 
                            color=plot_color,
                            alpha=0.5) # This line was generated by AI (DeepSeek)

        # Formatting
        plt.title(title)
        plt.xlabel(x_axis)
        plt.ylabel(y_axis)
        plt.grid(True, alpha=0.3)
        plt.legend()
        plt.xticks(rotation=45)
        plt.gca().xaxis.set_major_locator(mdates.AutoDateLocator(minticks=8, maxticks=12)) 
        plt.tight_layout()

        plt.show(block=False)  
        plt.close()       

    # ---------------------------------------------------
    # CREATE COMPARATIVE GRAPH OF DATA AND PREDICTOR
    # ---------------------------------------------------

    # This function was refined with the assitance of AI
        # Purpose: AI helped find better solutions for aligning the origins of both y-axis
        # AI Tool: DeepSeek

    def comparative_graph(self, df, columns, df_predictor, predictor, title, x_axis, y_axis, y_lims=None, zero_align=False):

        """
        Plots time-series data (primary y-axis) against a predictor variable (secondary y-axis) on twin axes.
        Handles mismatched dates and ensures visual distinction between variables.

        Args:
            df (pd.DataFrame): DataFrame containing time-series data to plot (primary axis).
            columns (list): List of column names in `df` to plot.
            df_predictor (pd.DataFrame): DataFrame containing the predictor variable (secondary axis).
            predictor (str): Column name in `df_predictor` to plot.
            title (str): Title of the plot.
            x_axis (str): Label for the x-axis.
            y_axis (str): Label for the primary y-axis.
            y_lims (tuple, optional): (min, max) limits for the secondary y-axis. If None, auto-scales. Defaults to None.
            zero_align (bool, optional): If True, aligns 0 on both y-axis. Defaults to False.
        """
        
        self.logger.debug(f"Plotting {len(columns)} variables vs {predictor}")

        #Input validation
        if df.empty or df_predictor.empty:
            raise ValueError("Input DataFrames cannot be empty.")
        if predictor not in df_predictor.columns:
            raise ValueError(f"Predictor column '{predictor}' not found.")

        # Converting Date column to datetime 
        df['Date'] = pd.to_datetime(df['Date'])
        df_predictor['Date'] = pd.to_datetime(df_predictor['Date'])

        # Find dateranges for overlapping datasets
        primary_non_nan = df[columns].notna().any(axis=1)
        primary_dates = df.loc[primary_non_nan, 'Date']
        predictor_non_nan = df_predictor[predictor].notna()
        predictor_dates = df_predictor.loc[predictor_non_nan, 'Date']

        x_min = max(primary_dates.min(), predictor_dates.min())
        x_max = min(primary_dates.max(), predictor_dates.max())

        # Filter datasets to this range
        df_overlap = df[(df['Date'] >= x_min) & (df['Date'] <= x_max)]
        df_predictor_overlap = df_predictor[(df_predictor['Date'] >= x_min) & (df_predictor['Date'] <= x_max)]
        if df_overlap.empty or df_predictor_overlap.empty:
            raise ValueError("No overlapping data points between datasets")

        # Create figure
        fig, ax1 = plt.subplots(figsize=(12, 6))
        colors = plt.rcParams['axes.prop_cycle'].by_key()['color'] #This line was generate by AI (DeepSeek)

        # The following block of code was generated with the help of AI
            # Purpose: Creating plots with different colours based on the given columns
            # AI Tool: DeepSeek

        # Primary y-axis: Plot all dependent variables
        for i, col in enumerate(columns):
            sns.scatterplot(data=df_overlap, x='Date', y=col, 
                            label=col, 
                            color=colors[i % len(colors)], 
                            alpha=0.5,
                            ax=ax1)
            
        # Calculate primary axis range
        y1_min = min(0, df_overlap[columns].min().min())
        y1_max = df_overlap[columns].max().max()
        y1_padding = (y1_max - y1_min) * 0.05
        ax1.set_ylim(y1_min - y1_padding, y1_max + y1_padding)

        # Secondary y-axis for independent variable
        ax2 = ax1.twinx()
        predictor_color = 'black'
        ax2.plot(df_predictor_overlap['Date'], df_predictor_overlap[predictor], 
                 label=predictor, 
                 color=predictor_color, 
                 lw=1, 
                 alpha=0.5) 

        # Set secondary axis limits
        predictor_data = df_predictor_overlap[predictor]
        predictor_min, predictor_max = predictor_data.min(), predictor_data.max()
        
        if y_lims is not None:
            ax2.set_ylim(y_lims)
        else:
            data_range = predictor_max - predictor_min
            padding = data_range * 0.2 if data_range < 10 else data_range * 0.1
            bottom = max(0, predictor_min - padding)
            top = predictor_max + padding
            ax2.set_ylim(bottom, top)

        # The following block of code was generated by AI
            # Purpose: Solving the problem of aligning the two y-axis
            # AI Tool: DeepSeek

        # Zero alignment
        if zero_align:
            fig.canvas.draw()
            original_bottom, original_top = ax2.get_ylim()
            original_range = original_top - original_bottom
            ax1_zero_disp = ax1.transData.transform((0, 0))[1]
            ax2_zero_disp = ax2.transData.transform((0, 0))[1]
            data_per_pixel = original_range / ax2.bbox.height
            required_shift = (ax1_zero_disp - ax2_zero_disp) * data_per_pixel
            ax2.set_ylim(original_bottom - required_shift, 
                        original_top - required_shift)

        # Graph formatting
        ax1.set_xlabel(x_axis)
        ax1.set_ylabel(y_axis, color='black')
        ax2.set_ylabel(predictor, color=predictor_color)
        ax1.tick_params(axis='y', labelcolor='black')
        ax2.tick_params(axis='y', labelcolor=predictor_color)
        ax1.grid(True, alpha=0.3) 
        ax1.set_xlim(x_min, x_max)
        ax1.xaxis.set_major_locator(mdates.AutoDateLocator())

        ax1.legend(loc='upper left', framealpha=0.9)
        ax2.legend(loc='upper right', framealpha=0.9)

        plt.title(title, pad=20)
        plt.xticks(rotation=45)
        plt.subplots_adjust(top=0.9)
        plt.tight_layout()
        plt.show(block=False)
        plt.close(fig) 
























class PredictiveGraphs:
    '''A class for creating graphs based on predictive analysis.'''

    def __init__(self, figsize=(14, 10)):

        """
        Initialize with default figure size.
        
        Args:
            figsize: Tuple (width, height) in inches
        """

        self.figsize = figsize
        self.style = {
            'historical': {'color': 'blue', 'marker': 'o', 'alpha': 0.3},
            'prediction': {'color': 'red', 'linestyle': '-'},
            'api': {'color': 'green', 'marker': 'o', 's': 80}
        }

    def _setup_plot(self, rows=1, cols=1, sharex=False):
        """Helper method to create consistent plot figures."""
        fig, ax = plt.subplots(rows, cols, figsize=self.figsize, sharex=sharex)
        if rows == 1 and cols == 1:
            ax = [ax] 
        return fig, ax

    def plot_full_overview(self, historical_df, forecast_temp, forecast_precip, forecast_wind, api_df):

        """
        Plot comprehensive overview of historical data, predictions and API forecast

        Args:
            historical_df: DataFrame with columns ['Date', 'temperature (C)', ...]
            forecast_temp: DataFrame with columns ['Date', 'Prediction']
            forecast_precip: DataFrame with columns ['Date', 'Prediction']
            forecast_wind: DataFrame with columns ['Date', 'Prediction']
            api_df: DataFrame with columns ['Date', 'API_Temp', 'API_Precip', 'API_Wind']
        """

        fig, ax = self._setup_plot(rows=3, sharex=True)

        # Temperature plot
        self._plot_single_metric(ax[0], historical_df['Date'], 
                               historical_df['temperature (C)'], 
                               forecast_temp['Date'], forecast_temp['Prediction'],
                               api_df['Date'], api_df['API_Temp'],
                               'Historical temp', 'Predicted temp', 'API temp', 
                               'Temperature (°C)')
        
        # Wind plot
        self._plot_single_metric(ax[1], historical_df['Date'],
                               historical_df['wind_speed (m/s)'],
                               forecast_wind['Date'], forecast_wind['Prediction'],
                               api_df['Date'], api_df['API_Wind'],
                               'Historical wind', 'Predicted wind', 'API wind',
                               'Wind (m/s)')

        # Precipitation plot
        self._plot_single_metric(ax[2], historical_df['Date'],
                               historical_df['precipitation (mm)'],
                               forecast_precip['Date'], forecast_precip['Prediction'],
                               api_df['Date'], api_df['API_Precip'],
                               'Historical precip', 'Predicted precip', 'API precip',
                               'Precipitation (mm)')

        plt.suptitle('Historical, Predicted and API Data: Temperature, Precipitation and Wind')
        plt.tight_layout()
        plt.show()

    def _plot_single_metric(self, ax, hist_dates, hist_values, 
                          pred_dates, pred_values,
                          api_dates, api_values,
                          hist_label, pred_label, api_label, ylabel):
        """Helper method to plot a single metric."""
        # Historical data
        ax.scatter(hist_dates, hist_values, 
                  label=hist_label, **self.style['historical'])
        
        # Prediction line
        ax.plot(pred_dates, pred_values, 
               label=pred_label, **self.style['prediction'])
        
        # API data
        ax.scatter(api_dates, api_values, 
                  label=api_label, **self.style['api'])
        
        ax.set_ylabel(ylabel)
        ax.legend()
        ax.grid(True, alpha=0.3)











    def plot_week_comparison(self, forecast_temp, forecast_precip, 
                           forecast_wind, api_df):
        """
        Plot 7-day comparison between model predictions and API forecast.
        
        Args:
            forecast_temp: DataFrame with columns ['Date', 'Prediction']
            forecast_precip: DataFrame with columns ['Date', 'Prediction']
            forecast_wind: DataFrame with columns ['Date', 'Prediction']
            api_df: DataFrame with columns ['Date', 'API_Temp', 'API_Precip', 'API_Wind']
        """
        # Date range setup
        today = pd.to_datetime(datetime.now().date())
        end = today + timedelta(days=7)
        
        # Filter data
        week_data = {
            'temp': forecast_temp[(forecast_temp['Date'] >= today) & 
                                (forecast_temp['Date'] <= end)],
            'wind': forecast_wind[(forecast_wind['Date'] >= today) & 
                                (forecast_wind['Date'] <= end)],
            'precip': forecast_precip[(forecast_precip['Date'] >= today) & 
                                    (forecast_precip['Date'] <= end)],
            'api': api_df[(api_df['Date'] >= today) & 
                         (api_df['Date'] <= end)]
        }

        fig, ax = self._setup_plot(rows=3, sharex=True)

        # Temperature comparison
        self._plot_comparison(ax[0], week_data['temp']['Date'], 
                            week_data['temp']['Prediction'],
                            week_data['api']['Date'], 
                            week_data['api']['API_Temp'],
                            'Predicted temp', 'API temp', 
                            'Temperature (°C)')
        
        # Wind comparison
        self._plot_comparison(ax[1], week_data['wind']['Date'],
                            week_data['wind']['Prediction'],
                            week_data['api']['Date'],
                            week_data['api']['API_Wind'],
                            'Predicted wind', 'API wind',
                            'Wind (m/s)')

        # Precipitation comparison
        self._plot_comparison(ax[2], week_data['precip']['Date'],
                            week_data['precip']['Prediction'],
                            week_data['api']['Date'],
                            week_data['api']['API_Precip'],
                            'Predicted precip', 'API precip',
                            'Precipitation (mm)')

        # Format x-axis
        plt.xticks(week_data['api']['Date'], 
                  [d.strftime('%a\n%m-%d') for d in week_data['api']['Date']])
        plt.xlabel('Date')
        plt.suptitle('7-Day Comparison: Temperature, Precipitation and Wind')
        plt.tight_layout()
        plt.show()

    def _plot_comparison(self, ax, pred_dates, pred_values,
                        api_dates, api_values,
                        pred_label, api_label, ylabel):
        """Helper method for comparison plots."""
        ax.plot(pred_dates, pred_values, f"{self.colors['prediction']}-", 
               label=pred_label)
        ax.scatter(api_dates, api_values, color=self.colors['api'], 
                  s=100, label=api_label)
        ax.set_ylabel(ylabel)
        ax.legend()
        ax.grid(True, alpha=0.3)










    def plot_results(self, test_data, target):
        """
        Plot pollution prediction results.
        
        Args:
            test_data: DataFrame with columns ['Date', target, 'Prediction']
            target: Column name for actual values ('PM10' or 'NO2')
        """
        fig, ax = self._setup_plot()
        
        ax.plot(test_data['Date'], test_data[target], 
               f"{self.colors['historical']}-", 
               label='Actual')
        ax.plot(test_data['Date'], test_data['Prediction'], 
               f"{self.colors['prediction']}--", 
               label='Predicted')
        
        ax.set_title(f'Pollution Prediction for {target} (2018)')
        ax.set_ylabel(f'{target} (µg/m³)')
        ax.legend()
        ax.grid(alpha=0.3)
        plt.tight_layout()
        plt.show()









def plot_comparison(train_df, test_df, target_var):
    """Compare model performance on train vs test data"""
    plt.figure(figsize=(12,6))
    
    # Training data
    plt.scatter(train_df['Date'], train_df[target_var], 
               color='blue', alpha=0.3, label='Actual (Train)')
    plt.plot(train_df['Date'], train_df['Prediction'],
            'b-', label='Predicted (Train)')
    
    # Test data
    plt.scatter(test_df['Date'], test_df[target_var],
               color='red', alpha=0.3, label='Actual (Test)')
    plt.plot(test_df['Date'], test_df['Prediction'],
            'r-', label='Predicted (Test)')
    
    plt.legend()
    plt.title(f'Train/Test Comparison: {target_var}')
    plt.show()