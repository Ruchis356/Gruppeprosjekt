
Spørsmål:
1. Sjekk om å bruke værdata og luftkvalitetdata for å forutsi fremtidig luftkvalitet er noe ala det de forventer. Burde vi gjøre mer? Mindre? Noe helt annet? 
    (altså er dette overordnede målet et godt svar på oppgaven: Hente og bruke historisk data om vær og luftkvalitet til å forutsi hvordan luftkvaliteten utvikler seg de neste dagene basert på været den siste tiden. )
2. Hvor mye data er det forventet at vi behandler? Er 10 år med daglige gjennomsnitt (nedbør, vind, luftkvalitet, o.l.) en passende mengde? Vi blir å behandle rundt 3650 datoer med 6 datapunkter hver med den planen vi har nå. 
3. Hva er egentlig forskjellen på en jupyter notebook og en .py fil? Når vi jobber gjennom GitHub, hva har jupyter som py ikke har? Skal vi bare bruke jupyter notebooks og ingen .py filer?




Har filtrert bort de fleste filer og mapper (?)

Remove hardcoding where possible





BARE ROT:


Use qgrid for interactive dataframes?


import unittest
import sys, os

# Add the parent directory of 'notebooks' to the sys.path
sys.path.insert(0, os.path.abspath(os.path.join(os.getcwd(), 'src')))


from DeckOfCards import DeckOfCards
from HandOfCards import HandOfCards
# Skriv din kode her:
...```

client ID: f0cfe822-6d2c-4d3c-80f8-cbf38b0c15a9

client secret: client_id = b8950f6f-769e-4fd6-b658-0be1b21fbff8




## Areas of improvement (suggested by DeepSeek):

1. Use list comprehensions to simplify some code?

Instead of a for loop:
zero_indices = [index for index in df.index if df.loc[index, col] == 0]

Look for other opportunities to replace loops with list comprehensions 
(e.g., when creating lists or filtering data)


2. pandasql to manipulate data with SQL-like queries?

from pandasql import sqldf
pysqldf = lambda q: sqldf(q, globals())

query = """
SELECT * FROM df_weather WHERE Temperature > 20
"""
result = pysqldf(query)
print(result)









Consistency in Formatting:

Ensure that all AI contributions in the code are annotated consistently. For example, some comments use "AI tool: DeepSeek," while others don’t. Standardizing this will make the documentation more professional.

Consider using a consistent prefix for AI-related comments, such as # AI-Assisted: or # AI-Generated:.

Clarify the Extent of AI Contributions:

For some entries, it’s unclear whether the AI generated the code entirely or only suggested improvements. For example:

In get_met, the block of if statements is described as "mainly generated by AI, lightly reworked." This is clear, but other sections (e.g., "minor changes to sys.path.insert") could benefit from similar clarification.

Consider adding a brief note about the extent of human involvement (e.g., "AI-generated, lightly edited" or "AI-suggested, fully implemented by the developer").

Highlight Human Contributions:

While it’s important to disclose AI use, it’s equally important to highlight where human judgment and creativity were applied. For example:

In get_nilu, you mention that AI suggested making the column name less specific. You could add a note about why you chose to implement this suggestion and how it improved the code.

In get_met, you could note that the decision to drop certain columns (e.g., "level", "timeResolution") was based on human judgment.

Document AI Limitations:

Consider adding a section in the "Detailed Use of AI" document that acknowledges the limitations of the AI tool. For example:

"While AI was helpful for generating code snippets and suggesting improvements, all code was reviewed and tested by the developer to ensure correctness and alignment with project requirements."

"AI suggestions were evaluated for relevance and appropriateness before implementation."

Include a Summary Section:

Add a summary at the end of the "Detailed Use of AI" document that provides an overview of how AI was used. For example:

"AI was primarily used for generating boilerplate code, suggesting improvements to error handling, and assisting with data formatting. All AI-generated code was reviewed and tested by the developer to ensure it met project standards."

Code Annotations for Error Handling:

In the get_met and get_nilu functions, the error-handling blocks are well-documented, but you could add a brief explanation of why these specific errors were chosen. For example:

"The ConnectionError and Timeout exceptions were added to handle potential issues with the Frost API, as suggested by AI."

Future-Proofing:

Consider adding a note about how AI contributions will be handled in future updates to the code. For example:

"Future updates to this codebase will continue to document AI contributions in a similar manner, ensuring transparency and accountability."





Summary of AI Contributions:

AI was used to generate boilerplate code, suggest improvements to error handling, and assist with data formatting.

All AI-generated code was reviewed, tested, and modified as necessary by the developer to ensure correctness and alignment with project requirements.

AI was particularly helpful in identifying edge cases (e.g., invalid inputs, API errors) and suggesting ways to handle them.

The use of AI accelerated development but did not replace human judgment, as all decisions about code implementation were made by the developer.